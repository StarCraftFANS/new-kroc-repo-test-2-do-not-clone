#INCLUDE "plumbing.module"
#INCLUDE "maths.module"
VAL []INT powers IS [10000, 1000, 100, 10, 1]:
PROC serialWriteDecInt (VAL INT n)
  INITIAL INT index IS 0:
  INITIAL INT number IS n:
  INITIAL BOOL neg IS FALSE:
  SEQ
    IF
      n < 0
        SEQ
          neg := TRUE
          number := n * (- 1)
      TRUE
        SKIP
    IF 
      neg 
        serialWrite("-")
      TRUE 
        SKIP
    WHILE (index < 5)
      INT digit:
      SEQ
        digit := number / powers[index]
        number := number REM powers[index]
        digit := digit + (INT '0')
        serialWrite([BYTE digit])
        index := index + 1
    
:
PROC calculator (CHAN REAL32 input?)
  REAL32 input.val:
  REAL32 angle:
  INT32 value:
  REAL32 test:
  WHILE TRUE
    SEQ
      test := 1.5
      --serialWrite("listening for input*n")
      input ? input.val
      --serialWrite("Doing calculation*n")
      angle := (100.0 * (ACOS (268.0/(input.val))))
      --serialWrite("Converting*n")
      value := INT32 ROUND angle
      --serialWrite("Done with convert")
      serialWriteDecInt (INT value)
      serialWrite("*n")
      
:

PROC magic (CHAN INT adc.input?, CHAN REAL32 out!)
  INT value:
  REAL32 val32:
  
  
  WHILE TRUE
    SEQ
      adc.input ? value
      --serialWrite("before round")
      val32 := REAL32 ROUND value
      --serialWrite("after round")
      out ! val32
      
      
:
    
PROC show (CHAN INT output?)
  INT val:
  
  WHILE TRUE
    SEQ
      output ? val
      serialWriteDecInt(val)
      serialWrite("*n")
    
:
PROC pinger(CHAN SIGNAL ping!)
  WHILE TRUE
    SEQ
      ping ! SIGNAL
      delay(150)
:
PROC main ()
  CHAN INT output:
  CHAN SIGNAL ping:
  CHAN REAL32 output.32:
  SEQ
    serialWrite("Hi*n")
    PAR
      pinger(ping!)
      --show(output?)
      adc.io(0,ping?,output!)
      magic(output?,output.32!)
      calculator(output.32?)
:
