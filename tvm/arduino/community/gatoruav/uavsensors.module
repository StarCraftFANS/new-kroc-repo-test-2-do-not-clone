#IF NOT (DEFINED (UAVSENSORS.MODULE))
#DEFINE UAVSENSORS.MODULE
#INCLUDE "imu.module"

VAL INT X IS 0:
VAL INT Y IS 1:

-- This runs at around 143 reading per second
PROC angles(VAL INT GYRO.X, GYRO.Y, ACCEL.X, ACCEL.Y, CHAN INT pitch!, roll!)
  
  [2]CHAN INT gyro.out, accel.out, accel.conv, gyro.smooth, gyro.degree:
  [2]CHAN SIGNAL sig.gyro, sig.accel:
  
  PAR

    ping(sig.gyro[X]!)
    ping(sig.gyro[Y]!)
    ping(sig.accel[X]!)
    ping(sig.accel[Y]!)
    -- Gyro adcs
    adc(GYRO.X, AREF, sig.gyro[X]?, gyro.out[X]!)
    adc(GYRO.Y, AREF, sig.gyro[Y]?, gyro.out[Y]!)
    -- Accel adcs
    adc(ACCEL.X,AREF, sig.accel[X]?, accel.out[X]!)
    adc(ACCEL.Y,AREF, sig.accel[Y]?, accel.out[Y]!)
  
    accel.conv.y(accel.out[Y]?, accel.conv[Y]!)
    accel.conv.x(accel.out[X]?, accel.conv[X]!)

    gyro.filter(gyro.out[Y]?, gyro.smooth[Y]!)
    gyro.filter(gyro.out[X]?, gyro.smooth[X]!)

    gyro.to.degrees(gyro.smooth[Y]?, gyro.degree[Y]!)
    gyro.to.degrees(gyro.smooth[X]?, gyro.degree[X]!)

    comp.filter(gyro.degree[Y]?, accel.conv[Y]?, roll!, 80, 1)
    comp.filter(gyro.degree[X]?, accel.conv[X]?, pitch!, 80, 1)
    
:

PROC level.flight (CHAN INT theta.x?, theta.y?, CHAN SERVO s, s2)
  INT pitch, roll, servo.pos.pitch, servo.pos.roll:
  SEQ
    s ! pos ; 90
    WHILE TRUE
      SEQ
        theta.x ? pitch
        theta.y ? roll
        
        servo.pos.pitch := (pitch * (-1)) + 90
        s ! pos ; servo.pos.pitch
        
        servo.pos.roll := (roll * (-1)) + 90
        s2 ! pos ; servo.pos.roll
        
      
:
PROC turn (INT VAL pitch, roll, bank.angle)
  SEQ
    IF 
      servo.pos.roll <> roll + 90 + bank.angle
        SEQ
          SEQ i = 0 for bank.angle    --This slowly initiates servo movement to the specified angle to initiate a roll condition
            servo.pos.pitch := (pitch) + 100
            s ! pos ; servo.pos.pitch
            
            servo.pos.roll := roll + 90 + i
            s ! pos ; servo.pos.roll
        
      TRUE
        SEQ
          servo.pos.pitch := (pitch * (-1)) + 90 + bank.angle -- This stabilizes the airplane at the specified bank angle
          s ! pos ; servo.pos.pitch
        
          servo.pos.roll := (roll * (-1)) + 90 + bank.angle
          s2 ! pos ; servo.pos.roll
    
:    
     
PROC turn.to.heading (CHAN INT theta.x?, theta.y?, heading?, CHAN SIGNAL sig, CHAN SERVO s, s2, VAL BOOL direction, VAL INT new.heading)
  INT pitch, roll, curr.dir:
  
  SEQ
    
    theta.x ? pitch
    theta.y ? roll
    heading ? curr.dir
    
    
    IF 
      curr.dirr = new.heading  -- If we are flying at the same heading as the new heading we want, then just keep flying
        SKIP
      turn.dir = LEFT
        WHILE (curr.dirr > (5 + new.heading)) AND (curr.dirr < (5 + new.heading))  -- If we want to specify a left turn, then we will turn to the left until we are within 5 degrees of our intended new heading.
          SEQ
            turn (pitch, roll, s, s2 35)
      turn.dir = RIGHT
        WHILE (curr.dirr > (5 + new.heading)) AND (curr.dirr < (5 + new.heading)) -- If we want to specify a right turn, then we will turn to the right until we are within 5 degrees of our intended new heading.
          SEQ
            turn (pitch, roll, s, s2, -35)
      TRUE
        SKIP
:
PROC servo.setup(CHAN SERVO s,VAL INT start.pos)

  SEQ
    s ! min ; 650
    s ! max ; 2350
    s ! div ; 180
    s ! pos ; 0
    s ! start
    s ! pos ; start.pos
:  
#ENDIF
