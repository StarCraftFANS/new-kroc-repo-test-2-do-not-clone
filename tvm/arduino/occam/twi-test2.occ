#INCLUDE "plumbing.module"
#INCLUDE "twi2.module"


BYTE FUNCTION MSB (VAL INT i)
  BYTE b:
  VALOF
    SEQ
      b := (BYTE (i >> 8))
    RESULT b
:

BYTE FUNCTION LSB (VAL INT i)
  BYTE b:
  VALOF
    SEQ
      b := (BYTE (i /\ #00FF))
    RESULT b
:

PROC status ()
  BYTE status:
  SEQ
    get.twi.status(status)
    serialWrite("[s] ")
    serialWriteInt(INT status)
    serialWrite("*n")
:

PROC write.byte (VAL BYTE dev, VAL INT addr, VAL BYTE b)
  SEQ
    --serialWrite("-> ")
    --serialWriteInt(INT addr)
    --serialWrite("*n") 
    twi.init() 
    twi.start()
    --status()
    twi.set.tx.addr((dev << 1))
    --status()
    twi.tx(MSB(addr))
    --status()
    twi.tx(LSB(addr))
    --status()
    twi.tx(b)
    --status()
    twi.stop()
:    

PROC read.byte (VAL BYTE dev, VAL INT addr, BYTE b)
  SEQ
    --serialWrite("<- ")
    --serialWriteInt(INT addr)
    --serialWrite("*n") 
    twi.init()
    twi.start()
    --status()
    twi.set.tx.addr((dev << 1))
    --status()
    twi.tx(MSB(addr))
    --status()
    twi.tx(LSB(addr))
    --status()
    --serialWrite("RESTART*n")
    twi.start()
    --status()
    --serialWrite("RX ADDR*n")
    twi.set.rx.addr((dev << 1) \/ 1)
    --status()
    --serialWrite("READ BYTE*n")
    twi.read.byte(TWI.NACK, b)
    --status()
    twi.stop()
:
    

PROC main ()
  BYTE b:
  VAL INT MAX IS 10:
  INT addr:
  SEQ
    SEQ OFFSET = 0 FOR 100 STEP 10
      SEQ 
        SEQ ADDR = 0 FOR MAX
          SEQ
            addr := ADDR + OFFSET
            serialWrite("[W ")
            serialWriteInt((addr + 65))
            serialWrite("]*n")
            write.byte (#50, addr, (BYTE (addr + 65)))
        SEQ ADDR = 0 FOR MAX
          SEQ
            addr := ADDR + OFFSET
            read.byte (#50, addr, b)
            serialWrite("[R ")
            serialWriteInt(INT b)
            serialWrite("]*n")
    STOP
:
