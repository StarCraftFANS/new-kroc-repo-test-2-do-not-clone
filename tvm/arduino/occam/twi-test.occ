#INCLUDE "plumbing.module"
#INCLUDE "twi.module"

PROC handle.response (CHAN TWI.RSP rsp?, BYTE code)
  SEQ
    code := #42
    rsp ? CASE
      ok ; code
        SEQ
          serialWrite(" => OK ")
          serialWriteInt(INT code)
          serialWrite("*n")
      
      data ; code
        SKIP
   
      error ; code
        SEQ
          IF
            code = TWI.REP.START
              serialWrite(" => REP START*n")
            code = TWI.MT.SLA.NACK
              serialWrite(" => TX SLA NACK*n")
            code = TWI.MR.SLA.NACK
              serialWrite(" => RX SLA NACK*n")
            code = TWI.MR.DATA.NACK
              serialWrite(" => RX DATA NACK*n")
            TRUE
              SEQ
                serialWrite(" => ERROR: ")
                serialWriteInt(INT code)
                serialWrite("*n")
                STOP
:

BYTE FUNCTION MSB (VAL INT i)
  BYTE b:
  VALOF
    SEQ
      b := (BYTE (i >> 8))
    RESULT b
:

BYTE FUNCTION LSB (VAL INT i)
  BYTE b:
  VALOF
    SEQ
      b := (BYTE (i /\ #00FF))
    RESULT b
:

VAL INT START IS 20:
VAL INT COUNT IS 10:

PROC write.byte (CHAN TWI.REQ req!, CHAN TWI.RSP rsp?)
  BYTE code:
  SEQ
    serialWrite("REQ: init*n")
    req ! init
    handle.response (rsp?, code)

    SEQ eeprom.addr = 0 FOR COUNT
      SEQ
        serialWrite("START WRITE: ")
        serialWriteInt(COUNT)
        serialWrite("*n")
        req ! start
        handle.response (rsp?, code)

        serialWrite("SET DEVICE ADDRESS*n")
        req ! tx.addr ; (#50 << 1) -- 10100000
        handle.response(rsp?, code)
       
        -- Write something to zero 
        serialWrite("SEND DATA*n")

        -- MSB of addr
        req ! tx ; MSB(eeprom.addr)
        handle.response(rsp?, code)

        -- LSB of addr
        req ! tx ; LSB(eeprom.addr)
        handle.response(rsp?, code)

        -- Write data
        req ! tx ; (BYTE (START + eeprom.addr)) -- #41 ... #46 
        handle.response(rsp?, code)

        -- A stop must be generated to make the EEPROM write.
        -- Stop the transaction
        serialWrite("STOP WRITE*n")
        req ! stop
        handle.response(rsp?, code)
:

PROC read.byte (CHAN TWI.REQ req!, CHAN TWI.RSP rsp?)
  BYTE code:
  SEQ
    
    SEQ eeprom.addr = 0 FOR COUNT
      SEQ
        serialWrite("READ START: ")
        serialWriteInt(COUNT)
        serialWrite("*n")
        req ! start
        handle.response (rsp?, code)

        serialWrite("SET DEVICE ADDRESS*n")
        req ! tx.addr ; ((#50 << 1) \/ 0) -- 10100000
        handle.response(rsp?, code)
   
        serialWrite("READ SEND ADDR*n")
        -- MSB of addr
        req ! tx ; MSB(eeprom.addr)
        handle.response(rsp?, code)
        -- LSB of addr
        req ! tx ; LSB(eeprom.addr)
        handle.response(rsp?, code)
        
        -- Send another start
        serialWrite("START AGAIN*n")
        req ! start
        handle.response(rsp?, code)
        
        -- CONTROL BYTE
        serialWrite("DEV ADDR AGAIN*n")
        req ! rx.addr ; ((#50 << 1) \/ 1) -- 10100001
        handle.response(rsp?, code)

        -- Stop things
        -- serialWrite("SEND STOP*n")
        -- req ! stop
        -- handle.response(rsp?, code)

        BYTE data:
        SEQ
          req ! rx ; TWI.NACK
          handle.response(rsp?, data)
          serialWrite("READ: ")
          serialWriteInt(INT data)
          serialWrite("*n")

: 

PROC write.byte.fast (CHAN TWI.REQ req!)
  SEQ
    serialWrite("WRITING*n")
    req ! init
    SEQ eeprom.addr = 0 FOR COUNT
      SEQ
        req ! start
        req ! tx.addr ; (#50 << 1) -- 10100000
        -- MSB of addr
        req ! tx ; MSB(eeprom.addr)
        -- LSB of addr
        req ! tx ; LSB(eeprom.addr)
        -- Write data
        req ! tx ; (BYTE (START + eeprom.addr)) -- #41 ... #46 
        -- A stop must be generated to make the EEPROM write.
        -- Stop the transaction
        req ! stop
:

PROC read.byte.fast (CHAN TWI.REQ req!, CHAN TWI.RSP rsp?)
  SEQ
    serialWrite("READING*n")
    SEQ eeprom.addr = 0 FOR COUNT
      SEQ
        req ! start
        req ! tx.addr ; ((#50 << 1) \/ 0) -- 10100000
        -- MSB of addr
        req ! tx ; MSB(eeprom.addr)
        -- LSB of addr
        req ! tx ; LSB(eeprom.addr)
        -- Send another start
        req ! start
        -- CONTROL BYTE
        req ! rx.addr ; ((#50 << 1) \/ 1) -- 10100001

        BYTE b:
        SEQ
          req ! rx ; TWI.NACK
          rsp ? data ; b
          serialWrite("READ: ")
          serialWriteInt(INT b)
          serialWrite("*n")

: 

PROC drive (CHAN TWI.REQ req!, CHAN TWI.RSP rsp?)
  SEQ
    write.byte(req!, rsp?)
    read.byte(req!, rsp?)
:

PROC drive.fast (CHAN TWI.REQ req!, CHAN TWI.RSP rsp?)
  SEQ
    write.byte.fast(req!)
    read.byte.fast(req!, rsp?)
:

VAL BOOL FAST IS FALSE:
PROC main ()
  CHAN TWI.REQ req:
  CHAN TWI.RSP rsp:
  IF
    FAST
      PAR
        -- heartbeat()
        twi.fast(req?, rsp!)
        SEQ
          drive.fast(req!, rsp?)
          heartbeat()
    NOT FAST
      PAR
        twi(req?, rsp!)
        SEQ
          drive(req!, rsp?)
          heartbeat()
:
  
