-- Top-level user process.
PROC tlup (CHAN BYTE scr!)
  SEQ
    scr ! 'H'
    scr ! 'e'
    scr ! 'l'
    scr ! 'l'
    scr ! 'o'
    scr ! ' '
    scr ! 'W'
    scr ! 'o'
    scr ! 'r'
    scr ! 'l'
    scr ! 'd'
    scr ! '!'
:

-- Occam process to interface with the the print function from the foreign function interface (FFI).
#PRAGMA EXTERNAL "PROC C.print (VAL []BYTE buffer) = 0"

INLINE PROC write.screen (VAL []BYTE buffer)
  C.print (buffer)
:

-- Screen process accepting characters to be written to the screen.
PROC screen (CHAN BYTE in?)
  VAL INT buffer.size IS 64:
  INITIAL INT len IS 0:
  [buffer.size]BYTE buffer:
  WHILE TRUE
    BOOL flush:
    SEQ
      -- Extended rendezvous here. If there is no extended rendezvous we might
      -- loose one character of output. This might happen if:
      --  * A process send a character on screen, blocks
      --  * It gets picked up by screen handler, which runs the process again
      --    (no further code in screen handler than in ? ch is executed)
      --  * The process had sent its last character, does no more
      --    communication and does the final return. Ie the program quits
      --    but the part of the screen handler which does output has never
      --    been executed and the last character is lost
#IF DEFINED (OCCAMPI)
      in ?? buffer[len]
        SEQ
#ELSE
      in ? buffer[len]
      SEQ
        SEQ
#ENDIF
          CASE buffer[len]
            #FF
              flush := TRUE
            '*n', '*c'
              flush, len := TRUE, (len + 1)
            ELSE
              SEQ
                len   := len + 1
                flush := len >= buffer.size
          IF
            flush
              SEQ
                #PRAGMA DEFINED buffer
                write.screen ([ buffer FOR len ])
                len := 0
            TRUE
              SKIP
:

-- The World running on the TVM:
--  -> the screen process to output data
--  -> the top-level user process
PROC the.world ()
  CHAN BYTE scr:
  PAR
    screen (scr)
    tlup (scr)
:
