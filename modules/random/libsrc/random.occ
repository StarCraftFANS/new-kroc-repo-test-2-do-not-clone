--
--	Random number generation
--	Copyright (C) 1985 David Morse
--	Copyright (C) 2009 Adam Sampson <ats@offog.org>
--
--	This library is free software; you can redistribute it and/or
--	modify it under the terms of the GNU Lesser General Public
--	License as published by the Free Software Foundation, either
--	version 2 of the License, or (at your option) any later version.
--
--	This library is distributed in the hope that it will be useful,
--	but WITHOUT ANY WARRANTY; without even the implied warranty of
--	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
--	Lesser General Public License for more details.
--
--	You should have received a copy of the GNU Lesser General Public
--	License along with this library.  If not, see
--	<http://www.gnu.org/licenses/>.
--

--** @module random

#INCLUDE "random.inc"

--{{{  primitive operations
--{{{  FUNCTION random.init
--* Initialise RNG state given (up to) 32 bits of initial entropy.
RANDOM.STATE FUNCTION random.init (VAL INT32 seed) IS
  [(seed >> 2) + 1] (RANDOM.STATE):
--}}}
--{{{  FUNCTION random.get
--* Generate 32 bits of random data.
-- Returns the data and a new RNG state.
INT32, RANDOM.STATE FUNCTION random.get (VAL RANDOM.STATE state)
  RANDOM.STATE new.state:

  VALOF
    --{{{  miscellaneous constants
    VAL INT32 magic IS 16807:
    VAL INT32 period IS 2147483647:
    VAL INT32 quotient IS period / magic:
    VAL INT32 remainder IS period \ magic:
    --}}}

    INT32 lo, hi, test:
    SEQ
      hi := state[seed] / quotient
      lo := state[seed] \ quotient
      test := (magic TIMES lo) MINUS (remainder TIMES hi)
      IF
        test > 0
          new.state[seed] := test
        TRUE
          new.state[seed] := test PLUS period
    RESULT new.state[seed], new.state
:
--}}}
--}}}
--{{{  state operations
--{{{  PROC random.init.from.time
--* Initialise an RNG using the current time as initial entropy.
PROC random.init.from.time (RESULT RANDOM.STATE state)
  TIMER tim:
  INT t:
  SEQ
    tim ? t
    state := random.init (INT32 t)
:
--}}}
--{{{  FUNCTION random.split
--* Given an RNG state, compute two new states deterministically from
-- it that have a low probability of generating overlapping sequences.
RANDOM.STATE, RANDOM.STATE FUNCTION random.split (VAL RANDOM.STATE state)
  RANDOM.STATE new.a, new.b:
  VALOF
    INT32 data:
    SEQ
      data, new.a := random.get (state)
      new.b := random.init (data)
    RESULT new.a, new.b
:
--}}}
--}}}
--{{{  generators
--{{{  FUNCTION random.int
INT, RANDOM.STATE FUNCTION random.int (VAL INT max, VAL RANDOM.STATE state)
  INT new.int:
  RANDOM.STATE new.state:
  VALOF
    INT32 data:
    SEQ
      data, new.state := random.get (state)
      new.int := INT (data \ (INT32 max))
    RESULT new.int, new.state
:
--}}}
--}}}
