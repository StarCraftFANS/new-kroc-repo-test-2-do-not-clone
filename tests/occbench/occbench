#!/usr/bin/env python
#
#	Harness for Performance Regression Testing in occam-pi
#	Copyright (C) 2009  Carl Ritson <cgr@kent.ac.uk>
#
#	This program is free software; you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation; either version 2 of the License, or
#	(at your option) any later version.
#
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with this program; if not, write to the Free Software
#	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

import sys, os, getopt, re, time

VERSION = "$Rev$"[6:-2]
CONTACT = "kroc-bugs@kent.ac.uk"

name_re = re.compile(r"^--\s*OCCBENCH\s+NAME\s*:\s*(.*)\s*$", re.MULTILINE)
type_re = re.compile(r"^--\s*OCCBENCH\s+TYPE\s*:\s*(.*)\s*$", re.MULTILINE)
prog_re = re.compile(r"(.*)\.occ$", re.IGNORECASE)
source_re = re.compile(r"\.occ$", re.IGNORECASE)

occbuild = "occbuild"
startup_runs = 1
test_runs = 3

def warn(*s):
	print >>sys.stderr, "occbench: " + "".join(map(str, s))

def die(*s):
	warn(*s)
	sys.exit(1)

def run_command(cmd):
	"""Run a program with arguments and return the exit code.
	Equivalent to subprocess.call, but works on Python 2.3 when os.spawnvp
	is available."""
	try:
		import subprocess
		return subprocess.call(cmd)
	except ImportError:
		return os.spawnvp(os.P_WAIT, cmd[0], cmd)

def time_command(cmd):
	t1 = time.time()
	rc = run_command(cmd)
	t2 = time.time()
	if rc != 0:
		die("Command failed: ", " ".join(cmd))
	else:
		return (t2 - t1)

def parse_file(path):
	f = open(path)
	if not f:
		warn("unable to open " + path)
		return

	data = f.read()
	f.close()

	test_name = name_re.search(data)
	test_type = type_re.search(data)
	test_path = prog_re.search(path)
	if test_name and test_type:
		test = { 
			'path'		: test_path.group(1),
			'source'	: path,
			'name'		: test_name.group(1),
			'type'		: test_type.group(1)
		}
		return test

def parse_dir(path):
	files = os.listdir(path)
	tests = {}
	for fn in files:
		if source_re.search(fn):
			fpath = os.path.join(path, fn)
			data = parse_file(fpath)
			if data:
				tests[fpath] = data
	return tests

def run_test(test, params, logs):
	path = test['path']
	type = test['type']
	
	# FIXME: something like...
	for i in range(startup_runs + test_runs):
		time = time_command([occbuild, "--run", path])
		if i >= startup_runs:
			pass # FIXME

def usage(f):
	print >>f, """occbench, version """ + VERSION + """
Run occam-pi benchmark tests 
Usage:

  occbench [OPTIONS] DIRECTORY [DIRECTORY ...]
    Run tests contained in DIRECTORY

Options:
  --append FILE    Append test log to FILE
  --occbuild PATH  Set path for occbuild to PATH
  --output FILE    Output test log to FILE
  --quiet          Do not log to STDOUT

Report bugs to <""" + CONTACT + """>."""

def main(args):
	global occbuild
	
	append_logs	= []
	logs		= [ sys.stdout ]
	output_logs	= []
	params		= {}
	tests		= {}

	# Parse the command line
	long_opts = [ "append=", "occbuild=", "output=", "quiet" ]
	
	try:
		opts, args = getopt.getopt(args, "", long_opts)
	except getopt.GetoptError:
		usage(sys.stderr)
		sys.exit(1)
	
	for (o, a) in opts:
		if o is "--append":
			append_logs.append(a)
		elif o is "--occbuild":
			occbuild = a
		elif o is "--output":
			output_logs.append(a)
		elif o is "--quiet":
			logs = []
	
	if args == []:
		die("No test directories specified")
	
	# Find and parse all the tests
	for dir in args:
		tests.update(parse_dir(dir))
	
	# Open all the log files appropriately
	for fn in append_logs:
		f = open(fn, 'a')
		if f:
			logs.append(f)
		else:
			die("Unable to open append log " + fn)
	for fn in output_logs:
		f = open(fn, 'w')
		if f:
			logs.append(f)
		else:
			die("Unable to open output log " + fn)

	# 

	# Run tests
	order = tests.keys()
	order.sort()
	for key in order:
		print tests[key]
		run_test(tests[key], params, logs)

if __name__ == "__main__":
	main(sys.argv[1:])

